---
title: "Summary of PARTS Simulations"
author: "Clay Morrow"
date: "7/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, error = FALSE)
```

```{r}
library(ggplot2)
```

# Introduction

This document will summarize the results of simulation studies used to evaluate
the robustness of the PARTS method. 

# Methods

## Model 

All data were generated with the following simulation model:

$$X(t) = \lambda L + \psi_1 R_1 + t(\alpha + \beta L +\psi_2 R_2 ) + (\gamma + \psi_3 R_3)W(t) + \varepsilon(t)$$ 

* $X(t)$ is the observed spatio-temporal variable at time $t$

* $L$ is a indicator variable for one of two land classes (0, 1) and $\lambda$ 
is the intercept effect of land class 1 relative to land class 0. Land class 
was generated in a regular (checkerboard) grid with granularity of 2, 4, or 8 
where one square block of land is 1/2, 1/4, or 1/8 the width of the map 
respectively.

* $\alpha$ is the baseline effect of time and $\beta$ is the interaction between 
time and land class

* $W(t) \sim N(0, \Sigma_w)$ is a spatio-temporal predictor, representing a climate
variable and $\gamma$ is the baseline effect of climate. $\Sigma_w$ is the 
covariance structure of $W$. 

* $R_1$, $R_2$, and $R_3$ are additional random effects on the intercept, time, 
and climate components of the model respectively. $\psi_i$ are magnitudes (
variance) of these random effects.

* $\varepsilon(t)$ is the spatio-temporally autocorrelated error term which 
follows an AR(1) process: $\varepsilon(t) = \rho \varepsilon(t-1) + \delta(t)$

  - $\rho$ is the AR parameter, which generates temporal autocorrelation, and

  - $\delta(t) \sim N(0, \Sigma)$ is the spatially autocorrelated error at time 
  $t$, generated with a tapered covariance function: 
  $\Sigma = I\eta + (1-\eta)f(D, \theta)$. 
  
    + $\eta$ is the variance-absorbing nugget,
    
    + $I$ is an identity matrix 
    
    + $f$ is a tapered covariance function. See below for the formulation.
    
    + $D$ is the geographic distance between points $i$ and $j$
    
    + $\theta$ is the effective range of the spatial autocorrelation. Below this
    distance, $f$ evaluates to 0.
    
    + Generations of $\Sigma_w$ follows from generation of $\Sigma$, 
    substituting $\theta$ for the climate-specific $\theta_w$.

$$f(D) =  \begin{cases} 0 & D < \theta \\ \big(\frac{1 - D}{\theta}\big)^2 \frac{1+D}{2\theta} & else \end{cases}$$

* $W(t)$ is also a generated by an AR process: $W(t) = \rho_w W(t-1) + \delta_w(t)$

  - $\rho_w$ is the AR parameter used to generates $W(t)$ and 
  
  - $\delta_w(t)$
  
* Each $R$ is a spatial variable following a 2D sin wave: $R = \sin(\frac{2\pi}{T_x}x + p_x + \frac{2\pi}{T_y}y + p_y) + \varepsilon$. 

  - Here, $x$ and $y$ are map coordinates. 
  
  - The following parameter values were selected to make realistically smooth
  transitions across the maps: $T_x = T_y = 0.6$ and $p_x = p_y = 45^\circ$. 
  
  - $\varepsilon \sim N(0, 1)$
  
  
  


# Results

```{r, load_data, include = FALSE}
# X(t) = lambda*land + S1*r1 + (alpha + beta*land + S2*r2 )*t + (gamma + S3*r3)*temp(t) e(t)

load("scripts/self-contained-batch-sim_script/sim-data/19-Jun_simulations/01_PARTS_sim-study.RData", 
     verbose = TRUE)
load("scripts/self-contained-batch-sim_script/sim-data/19-Jun_simulations/02_PARTS_sim-study.RData", 
     verbose = TRUE)
load("scripts/self-contained-batch-sim_script/sim-data/19-Jun_simulations/03_PARTS_sim-study.RData", 
     verbose = TRUE)
load("scripts/self-contained-batch-sim_script/sim-data/19-Jun_simulations/04_PARTS_sim-study.RData", 
     verbose = TRUE)
```

```{r, make_base_figs}
if (TRUE) {

  fig.width = 6 # inches

  if(!dir.exists("sim-figures")){
    dir.create("sim-figures")
  }

  library(ggplot2); library(dplyr)
  ## Function to create plotting data frame
  getdf <- function(L){
    df = L$sim.table %>%
      cbind(lapply(L$GLS, function(x){x$overall_stats$coefmean}) %>% bind_rows())
    df$p.int = lapply(L$GLS, function(x)x$t.pval[1, "pval.t"]) %>% unlist()
    df$p.land1 = lapply(L$GLS, function(x)x$t.pval[2, "pval.t"]) %>% unlist()
    df.melt = df %>%
      reshape2::melt(measure.vars = c("(Intercept)", "land1"),
                     variable.name = "coefficient", value.name = "estimate") %>%
      reshape2::melt(measure.vars = c("p.int", "p.land1"),
                     variable.name = "ptype", value.name = "pval") %>%
      filter(!(coefficient == "(Intercept)" & ptype == "p.land1"),
             !(coefficient == "land1" & ptype == "p.int")) %>%
      mutate(sig = (pval <= 0.05)) %>%
      unique() %>%
      arrange(simID, map.width) %>%
      # select(coefficient, ptype, estimate, pval)
      select(-ptype)
    return(df.melt)
  }

  ## Sim 1
  simplot <- function(obj, coef.name = "lambda", xvar = "map.width", ttl = "Sim study 1"){
    obj.df = getdf(obj) %>%
      mutate(coefficient = factor(coefficient, levels = c("(Intercept)", "land1"),
                                  labels = paste0(coef.name, 0:1))) %>%
      reshape2::melt(measure.vars = c("estimate", "sig")) %>%
      mutate(variable = factor(variable, levels = c("estimate", "sig"),
                               labels = c("Coefficient estimate", "Significant tests (prop.)")))

    obj.fig = obj.df %>%
      ggplot(aes(x = as.factor(get(xvar)), y = value, col = coefficient)) +
      geom_hline(data = data.frame(variable = c("Coefficient estimate", "Significant tests (prop.)"),
                                   val = c(0, 0.05)),
                 aes(yintercept = val), lty = 2, col = "grey80") +
      stat_summary(fun.data = "mean_se", geom = "errorbar", width = .05,
                   position = position_dodge(width = .1), alpha = .5) +
      stat_summary(fun.data = "mean_se", geom = "point", size = .8,
                   position = position_dodge(width = .1)) +
      stat_summary(fun.data = "mean_se", geom = "line", aes(group = coefficient),
                   position = position_dodge(width = .1), alpha = .5) +
      theme_classic() +
      theme(strip.background = element_blank(), strip.placement = "outside",
            text = element_text(size = 10),
            title = element_text(size = 10),
            strip.text = element_text(size = 10),
            legend.text = element_text(size = 10)) +
      facet_wrap(~ variable, scales = "free", strip.position = "left") +
      labs(x = xvar, y = NULL,
           subtitle = ttl)

    return(obj.fig)
  }

  # sim1
  (sim1.fig <- simplot(obj = sim1, xvar = "map.width", coef.name = "lambda",
                       ttl = "sim study #1"))
  # sim2
  (sim2.fig <- simplot(obj = sim2, xvar = "land.grid", coef.name = "beta",
                       ttl = "sim study #2"))
  # sim3
  (sim3.fig <- simplot(obj = sim3, xvar = "S2", coef.name = "gamma",
                       ttl = "sim study #3"))
  # sim4
  (sim4a.fig <- simplot(obj = sim4a, xvar = "S3", coef.name = "beta",
                        ttl = "sim study #4a"))
  (sim4b.fig <- simplot(obj = sim4b, xvar = "S2", coef.name = "beta",
                        ttl = "sim study #4b"))
  (sim4c.fig <- simplot(obj = sim4c, xvar = "S1", coef.name = "beta",
                        ttl = "sim study #4c"))
  (sim4d.fig <- simplot(obj = sim4d, xvar = "r", coef.name = "beta",
                        ttl = "sim study #4d"))

  ## save figures
  png(filename = file.path("sim-figures", "simfig_%03d.png"), width = fig.width,
      height = fig.width/2.5, units = "in", res = 600)
  plot(sim1.fig)
  plot(sim2.fig)
  plot(sim3.fig)
  plot(sim4a.fig)
  plot(sim4b.fig)
  plot(sim4c.fig)
  plot(sim4d.fig)
  dev.off()
}
```

4 Simulation studies were conducted to evaluate the robustness of the PARTS method.
During these studies, data were simulated and fit according to the PARTS method.

## Simulation study 1

The first study aimed to identify the effect of map size on Type I error rates
of purely spatial data. 

- Square maps with widths of 104, 144, 200, and 280 pixels were considered.

- Data were simulated for only one time point $t = 1$.

- All model parameters ($\lambda$, $\alpha$, $\beta$, $\gamma$, $\psi$) were 
  set to zero.
  
- The spatial range, nugget, and AR parameters were fixed for all simulations: 
  $\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.
  
- 200 simulations were conducted for each map size (n = 200, N = 800).
  
- granularity of $L$ was 2.
  
- $\lambda$ was the parameter of interest.
  
Below are figures showing the coefficient estimate (left) and Type I error
rate of $\lambda$ for the 2 land classes. Figures show mean $\pm$ 1 standard 
error. We can see that:

* coefficient estimates were very close to 0 for all map widths, though the
estimates converge on 0 with increasing map size.

* Type I error rates were as expected ($\approx 5\%$). 

* A very slight uptick in Type I error of $\lambda_0$ occurred for the 144 pixel
map, but this is likely due to the relatively small sample size of 200. Note 
that, even for this point, all 95% CI for Type I error rates contain 0.05.

```{r study_1, fig.width=6, fig.asp = 0.5}
sim1.fig %+% 
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(lambda[0]), expression(lambda[1])) ) %+%
  labs(x = "Map width (pixels)", subtitle = "Simulation study 1", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

```{r, include = FALSE}
library(lemon);library(dplyr)

getdf(sim1) %>% 
  mutate(coefficient = factor(coefficient, levels = c("(Intercept)", "land1"),
                                  labels = paste0("lambda", 0:1))) %>%
  select(map.width, coefficient, estimate, pval) %>% 
  ggplot(aes(y = pval)) + 
  # geom_vline(xintercept = 0, lty = 2, col = "black") +
  geom_histogram(fill = "grey90", col = "black") +
  # geom_boxplot() +
  stat_summary(fun.y = "mean", aes(x = 10, col = "mean"), geom = "point", size = 5, shape = "_") +
  stat_summary(fun.y = "median", aes(x = 10, col = "median"), geom = "point", size = 5, shape = "_") +
  theme_classic() +
  facet_rep_grid(coefficient~map.width, labeller = "label_both") 
```

## Simulation study 2

The second study aimed to test the effect of the size and number of land patches
 (granularity) on the Type I errors among temporal parameters.

- Two granularities were use to generate $L$: 2 and 8.

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1, meaning that land class 1 has $X$ values
0.1 higher than class 0 on average across the map.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were 
set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- 200 simulations were generated for each granularity (n = 200, N = 400).

- $\beta$ was the parameter of interest.

Below are the same 2 figures showing the coefficient estimates and Type I error
rates of $\beta$ for the 2 land classes. 

* coefficient estimates are very close to 0 for all both large and small land 
patches (2 and 8, respectively) even with a non-zero $\lambda$.

* Type I error rates were as expected ($\approx 5\%$) for $\beta_1$ but were 
slightly elevated for $\beta_0$ ($0.05 < P(\text{Type I}) <0.75$). However, 95% CIs contain 0.05.

```{r study_2, fig.width=6, fig.asp = 0.5}
sim2.fig %+% 
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(beta[0]), expression(beta[1])) ) %+%
  labs(x = "Land patch granularity", subtitle = "Simulation study 2", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```



## Simulation study 3

The thirds study aimed to test the Type I error associated with climate variable, with varying the temporal effects.

- Data were simulated with two values of $\psi_2$: 0 and 0.1

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were 
set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- granularity of $L$ was 2.

- 200 simulations were conducted for each value of $\psi_2$ (n = 200, N = 400).
  
- $\gamma$ was the parameter of interest  
  
Below are the figures of results. We can see that:

- While coefficient estimates were close to zero in both cases, including a random
temporal effect improved the accuracy of estimates (i.e., the estimates converged
on zero with increasing $\psi_2$).

- Type I error rates were as expected ($\approx 5\%$) but increased slightly in
the presence of the random effect.

```{r study_3, fig.width=6, fig.asp=0.5}
sim3.fig %+%
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(gamma[0]), expression(gamma[1])) ) %+%
  labs(x = expression(psi[2]),subtitle = "Simulation study 3", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

## Simulation study 4

The fourth study aimed to test the effect of various parameters on Type I
error rates of $\beta$. This study was broken down into 4 sub-studies, 
a, b, c, and d.

**Note** Perhaps I should redo (or add to) study 4 with a non-zero value of 
$\gamma$ as the baseline?

### 4a

Here we tested the effects of including effects of the climate term. We allow the effects of the climate term to vary spatially.

- Data were simulated with 2 levels of $\psi_3$: 0 and 0.1

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- granularity of $L$ was 2.

- 200 simulations were conducted for each value of $\psi_3$ (n = 200, N = 400).

- $\beta$ was the parameter of interest

From the results, below, we can see that:

- $\beta$ was estimated close to zero for both levels of $\psi_3$

- Type I error was as expected for when $\psi_3 = 0$ but was slightly 
elevated in $\beta_1$ at $\psi_3 = 0.1$. 

```{r study_4a, fig.width=6, fig.asp=0.5}
sim4a.fig %+%
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(beta[0]), expression(beta[1])) ) %+%
  labs(x = expression(psi[3]), subtitle = "Simulation study 4(a)", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

### 4b

Next, we tested the random effect of time:

- Data were simulated with 2 levels of $\psi_2$: 0 and 0.1

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- granularity of $L$ was 2.

- 200 simulations were conducted for each value of $\psi_2$ (n = 200, N = 400).

- $\beta$ was the parameter of interest

We can see from the below figures that:

- Estimates were close to zero

- Inclusion of a random temporal effect actually reduced the Type I error rate
of $\beta$.

```{r study_4b, fig.width=6, fig.asp=0.5}
sim4b.fig %+%
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(beta[0]), expression(beta[1])) ) %+%
  labs(x = expression(psi[2]), subtitle = "Simulation study 4(b)", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

### 4c

Then, we tested the effects of a random intercept effect.

- Data were simulated with 2 levels of $\psi_1$: 0 and 0.1

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- granularity of $L$ was 2.

- 200 simulations were conducted for each value of $\psi_1$ (n = 200, N = 400).

- $\beta$ was the parameter of interest

We can see from the results that:

- Estimates were close to 0

- Type I error was as expected.


```{r study_4c, fig.width=6, fig.asp=0.5}
sim4c.fig %+%
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(beta[0]), expression(beta[1])) ) %+%
  labs(x = expression(psi[1]),subtitle = "Simulation study 4(c)", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

### 4d

Finally, we tested the effect of varying the spatial range parameter:

- Data were simulated with 3 levels of $\theta$: 0.001, 0.05, and 0.1

- Square maps 104 pixels wide were used.

- 30 time points were used ($t = {1, 2, ..., 30}$).

- $\lambda$ was set to a constant 0.1.

- all other model parameters ($\alpha$, $\beta$, $\gamma$, and $\psi$) were set to zero.

- The spatial range, nugget, and AR parameters were fixed for all simulations: 
$\theta = 0.05$, $\eta = 0.1$, $\rho = 0.2$.

- granularity of $L$ was 2.

- 200 simulations were conducted for each value of $\psi_3$ (n = 200, N = 400).

- $\beta$ was the parameter of interest

Results show that:

- While estimates are close to zero, they begin to diverge with higher values
of $\theta$.

- Type I error rates are sufficiently low.

```{r study_4d, fig.width=6, fig.asp=0.5}
sim4d.fig %+%
  scale_color_manual(values = c("black", "grey50"), labels = c(expression(beta[0]), expression(beta[1])) ) %+%
  labs(x = expression(paste("Spatial range parameter (", theta,")")),
       subtitle = "Simulation study 4(d)", col = NULL) %+%
  theme(legend.position = c(.95, .9))
```

```{r}
# tmp %>% ggplot(aes(x = value, fill = coefficient)) + geom_histogram(bins = 50) + facet_wrap(~map.width, labeller = "label_both") + labs(x = "estimate")
# tmp %>% ggplot(aes(x = pval, fill = coefficient)) + geom_histogram(bins = 50) + facet_wrap(~map.width)
```

## Compute time

Here is a table of the time needed to conduct each study, in hours:

```{r}
tmp = as.data.frame(rbind(sim1 = sim1_time["elapsed"],
                          sim2 = sim2_time["elapsed"],
                          sim3 = sim3_time["elapsed"],
                          sim4 = sim4_time["elapsed"])) #seconds
tmp["total", "elapsed"] = sum(tmp$elapsed)
tmp <- tmp/3600 #hours
names(tmp) <- "elapsed_time_hrs"

tmp
```

# Conclusions

According to the results of the simulation studies contained in this document, 
PARTS is sufficiently robust at controlling Type I error and at isolating the
main effect, interactions of main effects with time, and effects of spatio-temporal
predictors. It is also robust against spatially varying parameters.


# New round of simulations: 09-Sept-2021

After receiving comments from Tony on 22-Aug-2021, We have added the following 
simulations.

## 1. Purely spatial with tests of land class effects

$$X(t) = \lambda L + \psi_1 R_1 + t(\alpha + \beta L +\psi_2 R_2 ) + (\gamma + \psi_3 R_3)W(t) + \varepsilon(t)$$

For these simulations, 

* No temporal autocorrelation: $\alpha = \beta = \psi_2 = 0$
* No spatio-temporal independent variable (i.e., climate): $\gamma = \psi_3 = 0$
* Spatial granularity of 4: **note:** 6 is not possible with my code: only 1, 2, 4, or 8:

```{r, echo = FALSE}
land.pattern.func <- function(land.grid = 4, map.width){
  ## Choose the appropriate structure based on land.grid
  if (land.grid == 1) {# all one land class
    pattern <-  matrix(1, ncol = 8, nrow = 8)
  } else if (land.grid == 2) { # 2 classes each 1/2 width of map
    pattern <- matrix(c(rep(c(1,0), each = 4, times = 4),
                        rep(c(0, 1), each = 4, times = 4)),
                      ncol = 8, byrow = TRUE)
  } else if (land.grid == 4) { # 2 classes each 1/4 width of map
    pattern <- matrix(rep(c(rep(c(1,0), each = 2, times = 4),
                            rep(c(0,1), each = 2, times = 4)), times = 2),
                      ncol = 8, byrow = TRUE)
  } else if (land.grid == 8) { # 2 classes 1/8 width of map
    pattern <-  matrix(rep(c(rep(c(1,0), times = 4),
                             rep(c(0,1), times = 4)), times = 4),
                       ncol = 8, byrow = TRUE)
  } else { # error handling
    stop("land.grid must be one of 1, 2, 4, or 8")
  }
  # make the land pattern
  land = kronecker(pattern, matrix(1, map.width/8, map.width/8))
  return(land)
}
```


```{r, fig.asp = .8, fig.width = 3}
map.width = 32
land <- land.pattern.func(land.grid = 4, map.width = map.width)
land.long <- land %>% reshape2::melt()

land.long %>% 
  ggplot(aes(x = Var1, y = Var2, fill = factor(value))) +
  geom_tile(col = "grey70") +
  scale_fill_manual(values = c("white", "grey50"))+
  labs(fill = "L", x = NULL, y = NULL) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        axis.ticks = element_blank(),
        axis.text = element_blank(), 
        legend.margin = margin(0,0,0,0))
```


* When $\psi_1 \neq 0$, the function to generate R1 should be fixed:

```{r echo = TRUE}
# 2D sin wave
sin_2d = function(x, y, A = 1, Tx = .6, Ty = .6, px = 45, py = 45){
  A * sin( (2*pi/Tx)*x + px + (2*pi/Ty)*y + py )
}

# function to generate random variables
fixed_r1 <- function(coord.x, coord.y, npix, npeaks){
  tx = ty = 1/(npeaks/2)
  -scale(sin_2d(coord.x, coord.y, Tx = tx, Ty = ty, px = 45, py = 45, A = npix))
}
```

### a. Effect of random spatial autocorrelation ($\theta$)

* constant land class effects: $\lambda_0 = 0$, $\lambda_1 = 0.2$
* $\varepsilon \sim N(0, \Sigma)$:

```{r, eval = FALSE, echo = TRUE}
eps = scale(Sigma %*% matrix(rnorm(ntime), nrow = npix))
```

* no spatially-dependant intercept: $\psi_1 = 0$
* variable range parameter: $\theta = \{0, 0.05, 0.25\}$
* 500 (n) simulations per case: 
$\text{N} = 500~ \text{n} \times 3~ \text{cases} = 1500$

The desired output is a table/figure of $\lambda_1 - \hat{\lambda_1}$ and 
potentially empirical 95% intervals (if 500 n is feasible). 

### b. Effect of $\theta$ with non-Gaussian errors

Same as (a) but with $\varepsilon$ generated from a $t_3$ distribution
rather than a normal distribution:

* $\varepsilon \sim T(3)\Sigma$:

```{r, eval = FALSE, echo = TRUE}
eps = scale(Sigma %*% matrix(rt(ntime, df = 3), nrow = npix))
```

* no spatially-dependant intercept: $\psi_1 = 0$
* **Different case sets:**
  - Case set 1: 500 n each for $\lambda_1 = 0.2$ and $\theta = \{0, 0.05, 0.25\}$
  - Case set 2: 1000 n each for $\lambda_1 = 0$ and $\theta = 0.05$

The desired output is a table/figure of $\lambda_1 - \hat{\lambda_1}$ **and**
a visualization of Type I errors when $\lambda_1 = 0$ and $\theta = .05$


### c. Effect of fixed spatial autocorrelation ($R_1$)

* constant land class effects: $\lambda_0 = 0$, $\lambda_1 = 0.2$
* no spatial autocorrelation: $\theta = 0$
* $\varepsilon \sim N(0, \sigma\Sigma)$
* constant $\psi_1 = 2\sigma_{\varepsilon}$: or another value to ensure that 
R dominates over $\varepsilon$.
* R generated with $T_x = T_y$ such that there 3 cases: are $1^2$, $2^2$, and $3^2$ 
peaks. When there are $2^2$ peaks, they should align with the center of $L=1$ blocks
* 200 n for each case. Below is the example for $2^2$ peaks **Note:** I could 
not figure out how to get the peaks to align **exactly** in the center of the 
blocks, but the default is pretty close:

```{r, fig.asp = .9, fig.width = 3, echo = FALSE}
coord.base = seq(0, 1, length.out = map.width)
coords = cbind(x = rep(coord.base, times = map.width),
               y = rep(coord.base, each = map.width))
land.long$coords.x = coords[, "x"]
land.long$coords.y = coords[, "y"]
land.long$sin1 = fixed_r1(land.long$coords.x, land.long$coords.y, 
                         npix = map.width^2, npeaks = 1^2) 
land.long$sin2 = fixed_r1(land.long$coords.x, land.long$coords.y, 
                         npix = map.width^2, npeaks = 2^2) 
land.long$sin3 = fixed_r1(land.long$coords.x, land.long$coords.y, 
                         npix = map.width^2, npeaks = 3^2) 

ggplot(land.long, aes(x = coords.x, y = coords.y, fill = sin1, col = factor(value))) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "orange") +
  scale_color_manual(values = c("white", "black")) + 
  labs(x = NULL, y = NULL, col = "L", fill = expression(epsilon[f]), 
       subtitle = expression(T[xy] == 1^2)) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        axis.ticks = element_blank(),
        axis.text = element_blank(), 
        legend.margin = margin(0,0,0,0))

ggplot(land.long, aes(x = coords.x, y = coords.y, fill = sin2, col = factor(value))) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "orange") +
  scale_color_manual(values = c("white", "black")) + 
  labs(x = NULL, y = NULL, col = "L", fill = expression(epsilon[f]),
       subtitle = expression(T[xy] == 2^2)) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        axis.ticks = element_blank(),
        axis.text = element_blank(), 
        legend.margin = margin(0,0,0,0))

ggplot(land.long, aes(x = coords.x, y = coords.y, fill = sin3, col = factor(value))) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "orange") +
  scale_color_manual(values = c("white", "black")) + 
  labs(x = NULL, y = NULL, col = "L", fill = expression(epsilon[f]),
       subtitle = expression(T[xy] == 3^2)) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        axis.ticks = element_blank(),
        axis.text = element_blank(), 
        legend.margin = margin(0,0,0,0))
```

Desired output: $\lambda_1 - \hat{\lambda_1}$ - possibly added to previous Sims


### d. Map Size

No need to do additional sims (see the original set.)

## 2. Spatio-temporal with tests of time trends

$$X(t) = \lambda L + \psi_1 R_1 + t(\alpha + \beta L +\psi_2 R_2 ) + (\gamma + \psi_3 R_3)W(t) + \varepsilon(t)$$


* constant land class effects: $\lambda_0 = 0$, $\lambda_1 = 0.2$
* constant effect of time: $\alpha = \beta_0 = \psi_2 = 0$, and $\beta_1 = \frac{1}{30}$
* no nugget: $\eta = 0$ and tapered covariance
* constant AR parameter: $\rho = 0.4$
* variable effect of spatial range: $\theta = \{0, 0.05, 0.25\}$
* no Spatio-temporal indpendent variable: $\gamma = \phi_3 = 0$
* No fixed spatial autocorrelation: $\psi_1 = 0$
* n = 200 per case

Desired results are $\beta - \hat{\beta}$ with 95% range

## 3. Spatio-temporal with test of spatio-temporal independent variable

$$X(t) = \lambda L + \psi_1 R_1 + t(\alpha + \beta L +\psi_2 R_2 ) + (\gamma + \psi_3 R_3)W(t) + \varepsilon(t)$$

* constant land class effects: $\lambda_0 = 0$, $\lambda_1 = 0.2$
* no fixed spatial effect: $\phi_1 = 0$
* no effect of time: $\alpha = \beta = \phi_2 = 0$
* constant effect of climate variable: $\gamma = 1$ and $\phi_3 = 0$
* constant spatial range (error): $\theta = 0.25$
* variable spatial range of climate: $\theta_W = \{0, 0.25\}$
* variable AR parameter of climate: $\rho_W = \{0, 0.4\}$
* no nugget (error or climate): $\eta = 0$
* n = 200 for each case.

Desired results are $\gamma - \hat{\gamma}$

### Estimated time for second round

1) 1500 sims ~ 30 hrs * 3.75 = 112.5 hrs = 4.68 days
2) 2500 sims ~ 30 hrs * 6.25 = 187.5 hrs = 7.81 days
3) 600 sims ~ 30 hrs * 1.5 = 45 hrs = 1.875 days
4) 600 sims ~ 30 hrs * 1.5 = 45 hrs = 1.875 days
5) 600 sims ~ 30 hrs * 1.5 = 45 hrs = 1.875 days

total = 112.5 + 187.5 + 3*45 = 435 hrs = 18.13 days...

## Results

```{r}
# sim 2-1
load("scripts/self-contained-batch-sim_script/sim-data/2-01a_PARTS_sim-study.RData", verbose = TRUE)
load("scripts/self-contained-batch-sim_script/sim-data/2-01b_PARTS_sim-study.RData", verbose = TRUE)
load("scripts/self-contained-batch-sim_script/sim-data/2-01c_PARTS_sim-study.RData", verbose = TRUE)
sim2.1_time <- colSums(rbind(sim2.1a_time, sim2.1b_time, sim2.1c_time))
# sim 2-2
load("scripts/self-contained-batch-sim_script/sim-data/2-02_PARTS_sim-study.RData", verbose = TRUE)
# sim 2-3
load("scripts/self-contained-batch-sim_script/sim-data/2-03_PARTS_sim-study.RData", verbose = TRUE)
```

```{r}
 simplot <- function(obj, coef.name = "lambda", xvar = "map.width", ttl = "Sim study 1"){
    obj.df = getdf(obj) %>%
      mutate(coefficient = factor(coefficient, levels = c("(Intercept)", "land1"),
                                  labels = paste0(coef.name, 0:1))) %>%
      reshape2::melt(measure.vars = c("estimate", "sig")) %>%
      mutate(variable = factor(variable, levels = c("estimate", "sig"),
                               labels = c("Coefficient estimate", "Significant tests (prop.)")))

    obj.fig = obj.df %>%
      ggplot(aes(x = as.factor(get(xvar)), y = value, col = coefficient)) +
      geom_hline(data = data.frame(variable = c("Coefficient estimate", "Significant tests (prop.)"),
                                   val = c(0, 0.05)),
                 aes(yintercept = val), lty = 2, col = "grey80") +
      stat_summary(fun.data = "mean_se", geom = "errorbar", width = .05,
                   position = position_dodge(width = .1), alpha = .5) +
      stat_summary(fun.data = "mean_se", geom = "point", size = .8,
                   position = position_dodge(width = .1)) +
      stat_summary(fun.data = "mean_se", geom = "line", aes(group = coefficient),
                   position = position_dodge(width = .1), alpha = .5) +
      theme_classic() +
      theme(strip.background = element_blank(), strip.placement = "outside",
            text = element_text(size = 10),
            title = element_text(size = 10),
            strip.text = element_text(size = 10),
            legend.text = element_text(size = 10)) +
      facet_wrap(~ variable, scales = "free", strip.position = "left") +
      labs(x = xvar, y = NULL,
           subtitle = ttl)

    return(obj.fig)
  }
```


### compute time

```{r}
## Calculate time
times.2 <- data.frame(rbind("2-1" = sim2.1_time[1:3], "2-2" = sim2.2_time[1:3], "3-3" = sim2.3_time[1:3]))
times.2["total", ] = colSums(times.2)

times.2$hours = round(times.2$elapsed/3600, 2)
times.2$days = round(times.2$hours/24, 2)

times.2[, c("hours", "days")]
```


### 1

####a

```{r}
# summary(sim2.1a$sim.table %>% mutate_all(factor))

dat2.1a <- getdf(sim2.1a) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate))

tmp2.1a <- dat2.1a %>% 
  group_by(coefficient, r) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n()) %>% 
  mutate(coefficient = ifelse(coefficient == "land1", "lambda1", "lambda0"),
         r = factor(round(r, 3)))

tmp2.1a %>% arrange(coefficient, r) %>% knitr::kable(digits = 3)
```

```{r, fig.asp = .7, fig.width = 4.5}
pd <- position_dodge(width = .2)

ggplot(tmp2.1a, aes(x = r, y = mean.dif, ymin = lwr.95, max = upr.95, 
                    col = coefficient)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(lambda - hat(lambda)), x = expression(theta), col = NULL,
       title = "Gaussian errors") +
  scale_color_manual(values = c("black", "grey50"),
                     labels = c(expression(lambda[1]), expression(lambda[0]))) + 
  theme_classic()
```

```{r, fig.asp = .5, fig.width = 5}
typeI <- dat2.1a %>% 
  filter(coefficient != "land1")
  
typeI %>%   
  ggplot(aes(x = pval, y = ..density..)) + 
  geom_histogram(bins = 20, col = "black", fill = "grey80", boundary = 0) +
  # facet_rep_wrap(~ as.character(ifelse(coefficient == "land1", 
  #                                      expression(lambda[1]), 
  #                                      expression(lambda[0]))),
  #                labeller = label_parsed, scales = "free_y") + 
  annotate("text", x = 0, y = 1.17, label = paste0("Type I Error = ", 100*round(mean(typeI$sig), 3), "%"), size = 3, hjust = 0) +
  annotate("text", x = 0, y = 1.09, label = paste0("n = ", nrow(typeI)), size = 3, hjust = 0) +
  theme_classic() + 
  theme(strip.background = element_blank()) +
  labs(subtitle = "Gaussian errors")
```


#### b

```{r}
## 1-b1
dat2.1b1 <- getdf(sim2.1b1) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate))

tmp2.1b1 <- dat2.1b1 %>% 
  group_by(lambda, coefficient, r) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE), 
            n = n()) %>% 
  mutate(coefficient = ifelse(coefficient == "land1", "lambda1", "lambda0"),
         true.coef = ifelse(coefficient == "lambda1", 0.2, 0),
         r = factor(round(r, 3)),
         lambda = factor(round(lambda, 3)))

tmp2.1b1 %>% arrange(lambda, coefficient, r) %>% 
  select(true.coef, coefficient, r, mean.dif, median.dif, lwr.95, upr.95, sig.prop, n) %>% 
  knitr::kable(digits = 3)
```

```{r, fig.asp = .7, fig.width = 4.5}
ggplot(tmp2.1b1, aes(x = r, y = mean.dif, ymin = lwr.95, max = upr.95, 
                    col = coefficient)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(lambda - hat(lambda)), x = expression(theta), col = NULL,
       title = "non-Guassian errors") +
  scale_color_manual(values = c("black", "grey50"),
                     labels = c(expression(lambda[1]), expression(lambda[0]))) + 
  theme_classic()
```


```{r}
## 1-b2
dat2.1b2 <- getdf(sim2.1b2) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate))

tmp2.1b2 <- dat2.1b2 %>% 
  group_by(lambda, coefficient, r) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n()) %>% 
  mutate(coefficient = ifelse(coefficient == "land1", "lambda1", "lambda0"),
         r = factor(round(r, 3)),
         lambda = factor(round(lambda, 3)))



tmp2.1b2 %>% arrange(lambda, coefficient, r) %>% knitr::kable(digits = 3)
```
```{r, fig.asp = .5, fig.width=5}
typeI_t <- dat2.1b1 %>% 
  filter(coefficient != "land1") %>%
  rbind(dat2.1b2)

typeI_t %>% 
  ggplot(aes(x = pval, y = ..density..)) + 
  geom_histogram(bins = 20, col = "black", fill = "grey80", boundary = 0) +
  # facet_rep_wrap(~ as.character(ifelse(coefficient == "land1", 
  #                                      expression(lambda[1]), 
  #                                      expression(lambda[0]))),
  #                labeller = label_parsed, scales = "free_y") + 
  annotate("text", x = 0, y = 1.17, label = paste0("Type I Error = ", 100*round(mean(typeI_t$sig), 3), "%"), size = 3, hjust = 0) +
  annotate("text", x = 0, y = 1.09, label = paste0("n = ", nrow(typeI_t)), size = 3, hjust = 0) +
  theme_classic() + 
  theme(strip.background = element_blank()) +
  labs(subtitle = "non-Gaussian errors")
```

#### c

```{r}
## 1-b2
dat2.1c1 <- getdf(sim2.1c1) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate),
         Tx.Ty = factor(1^2))
dat2.1c2 <- getdf(sim2.1c2) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate),
         Tx.Ty = factor(2^2))
dat2.1c3 <- getdf(sim2.1c3) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", lambda - estimate, 0 - estimate),
         Tx.Ty = factor(3^2))
dat1.1c <- rbind(dat2.1c1, dat2.1c2, dat2.1c3)


tmp2.1c <- dat1.1c %>% 
  group_by(coefficient, Tx.Ty) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n())



tmp2.1c %>% knitr::kable(digits = 3)
```

```{r, fig.asp = .7, fig.width = 4.5}
pd <- position_dodge(width = .2)

ggplot(tmp2.1c, aes(x = Tx.Ty, y = mean.dif, ymin = lwr.95, max = upr.95, 
                    col = coefficient)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(lambda - hat(lambda)), x = expression(T[xy]), col = NULL,
       title = "Fixed spatial autocorrelation") +
  scale_color_manual(values = c("black", "grey50"),
                     labels = c(expression(lambda[1]), expression(lambda[0]))) + 
  theme_classic()
```

### 2

```{r}
dat2.2 <- getdf(sim2.2) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", beta - estimate, 0 - estimate))

tmp2.2 <- dat2.2 %>% 
  group_by(beta, coefficient, r) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n()) %>% 
  mutate(coefficient = ifelse(coefficient == "land1", "beta1", "beta0"),
         true.coef = ifelse(coefficient == "beta1", 1/30, 0),
         r = factor(round(r, 3)))

tmp2.2 %>% arrange(beta, coefficient, r) %>% knitr::kable(digits = 3)
```
```{r}
ggplot(tmp2.2, aes(x = r, y = mean.dif, ymin = lwr.95, max = upr.95, 
                    col = coefficient)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(beta - hat(beta)), x = expression(theta), col = NULL) +
  scale_color_manual(values = c("black", "grey50"),
                     labels = c(expression(beta[1]), expression(beta[0]))) + 
  theme_classic()
```


### 3

```{r}
dat2.3 <- getdf(sim2.3) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", gamma - estimate, gamma - estimate))

tmp2.3 <- dat2.3 %>% 
  group_by(temp.r, AR_W, coefficient) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n()) %>% 
  mutate(coefficient = ifelse(coefficient == "land1", "gamma1", "gamma0"),
         true.coef = ifelse(coefficient == "gamma1", 1, 1)) 

tmp2.3 %>% arrange(coefficient, temp.r, AR_W, coefficient) %>% knitr::kable(digits = 3)
```
```{r, fig.width = 3.5, fig.asp = .75}
tmp2.3 %>% filter(coefficient == "gamma0") %>% 
ggplot(aes(x = factor(temp.r), y = mean.dif, ymin = lwr.95, max = upr.95, 
                    col = factor(AR_W))) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(gamma - hat(gamma)), x = expression(theta[w]), col = NULL) +
  scale_color_manual(name = expression(rho[w]), values = c("black", "grey50"),
                     labels = c(0, 0.4)) +
  theme_classic()  
```
For the GLS model $\gamma \sim land$, we get two results: $\hat\gamma_0$ and 
$\hat\gamma_1$ even though there is only one $\gamma$ parameter. In our results,
$\hat\gamma_0 \approx 1$ means the effect of the climate variable is about 1, while
$\hat\gamma_0 \approx 0$ means that the difference between land class 0 and land 
class 1 is about 0 (i.e., the effect is constant across land class).

```{r}
getdf(sim2.3) %>% 
  mutate(coef.dif = ifelse(coefficient == "land1", 
                           gamma - estimate, gamma - estimate)) %>% 
  filter(coefficient != "land1") %>% 
  ggplot(aes(x = temp.r, y = -log10(pval))) +
  geom_point() + 
  facet_wrap(~ AR_W)
```


# All Results

```{r, fig.width = 3.5, fig.asp = .8}
pd = position_dodge(width = .1)

tmp.newest <- getdf(sim1) %>%
  mutate(coef.dif = ifelse(coefficient == "land1", gamma - estimate, gamma - estimate)) %>% 
  group_by(map.width, coefficient) %>% 
  summarize(mean.dif = mean(coef.dif, na.rm = TRUE),
            median.dif = median(coef.dif, na.rm = TRUE),
            lwr.95 = quantile(coef.dif, probs = .025),
            upr.95 = quantile(coef.dif, probs = .975),
            sig.prop = mean(sig == TRUE, na.rm = TRUE),
            n = n())

tmp.newest %>% 
  ggplot(aes(x = factor(map.width), y = mean.dif, ymin = lwr.95, ymax = upr.95, col = coefficient)) +
  geom_hline(yintercept = 0, lty = 2, col = "grey80") +
  geom_errorbar(width = .02, position = pd, lty = 1) +
  geom_point(position = pd) +
  labs(y = expression(lambda - hat(lambda)), x = "Map width", col = NULL) +
  scale_color_manual(values = c("black", "grey50"),
                     labels = c(expression(lambda[1]), expression(lambda[0]))) + 
  theme_classic() +
  theme(legend.position = c(.9, .9))
```

```{r}
getdf(sim1) %>%
  mutate(coef.dif = ifelse(coefficient == "land1", 
                           gamma - estimate, gamma - estimate)) %>% 
  ggplot(aes(x = pval)) +
  geom_histogram(aes(y = ..density..), binwidth = .05, 
                 col = "black", fill = "grey70") + 
  facet_rep_wrap(~ paste("map width =", map.width)) + 
  theme_classic() + theme(strip.background = element_blank())

# across map widths
# getdf(sim1) %>%
#   mutate(coef.dif = ifelse(coefficient == "land1", 
#                            gamma - estimate, gamma - estimate)) %>%
#   ggplot(aes(x = pval)) +
#   geom_histogram(aes(y = ..density..), binwidth = .05, 
#                  col = "black", fill = "grey70") + 
#   theme_classic() + theme(strip.background = element_blank())
```


## Look at P-value histograms

# Junk

```{r, eval = FALSE}
tmp <- sim_PARTs(ntime = 9, par.sims = 1, debug = TRUE)
```

```{r, fig.asp = .9, fig.width = 5.5, eval = FALSE}
tmp$data %>% 
  reshape2::melt(measure.vars = paste("X", 1:9, sep = ".")) %>% 
  ggplot(aes(x = x.coord, y = y.coord, fill = value)) +
  geom_tile() + 
  facet_wrap(~ gsub(pattern = "X\\.", replacement = "t = ", variable)) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  labs(x = NULL, y = NULL, fill = "X") +
  theme(axis.text = element_blank(), axis.ticks = element_blank(), 
        panel.background = element_blank(), strip.background = element_blank())
```

```{r, eval = FALSE}
# exponential covariance function
exp_covar <- function(dst, rng){
  covar = exp(-dst/rng) # exponential covariance function
  return(covar)
}

# spherical tapering function
taper_covar <- function(dst, rng){
  ts = ifelse(dst > rng, 0, ((1 - dst/rng)^2) * (1 + dst/(2 * rng)) )
  return(ts)
}

## Taper covar
curve(taper_covar(x, r = .05), from = 0, to = 1, lty = 1,
      xlab = "D", ylab = "cor")
curve(taper_covar(x, r = .1), from = 0, to = 1, lty = 2, add = T)
curve(taper_covar(x, r = .25), from = 0, to = 1, lty = 3, add = T)
curve(taper_covar(x, r = .4), from = 0, to = 1, lty = 4, add = T)
legend(title = expression(theta), x = .6, y = 1, legend = c(.05, .10, .25, .40), lty = c(1:4))


## Exponential covar
curve(exp_covar(x, r = .05), from = 0, to = 1, lty = 1, 
      xlab = "D", ylab = "cor")
curve(exp_covar(x, r = .1), from = 0, to = 1, lty = 2, 
      add = TRUE)
curve(exp_covar(x, r = .25), from = 0, to = 1, lty = 3, 
      add = TRUE)
curve(exp_covar(x, r = .4), from = 0, to = 1, lty = 4, 
      add = TRUE)
legend(title = expression(r), x = .6, y = 1, legend = c(.05, .10, .25, .40), lty = c(1:4))

# ## compare
# curve(taper_covar(x, r = .05), from = 0, to = 1, lty = 1, col = "blue",
#       xlab = "D", ylab = "cor")
# curve(exp_covar(x, r = .05^1.5), from = 0, to = 1, lty = 2, col = "blue",
#       add = TRUE)
# curve(taper_covar(x, r = .25), from = 0, to = 1, lty = 1, col = "green",
#       add = T)
# curve(exp_covar(x, r = .25^1.5), from = 0, to = 1, lty = 2, col = "green",
#       add = T)
```


